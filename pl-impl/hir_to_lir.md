
# TODO List
- Assign locations in the binary for static strings.
- Replace `[... label(Var), NextInstr ...]` with `[... NextInstr ...]` but save the index of `NextInstr` under the label `Var`.
- Expand HIR instructions and immediate values to LIR (bytes). One HIR instruction may (and often does) expand to multiple bytes.

# First Pass
- Collect the names of all the top-level items
    + Also generate unique label symbols for string constants
- Put them in a list made of structures like `lbl_idx_val(-LabelSym, --Index, -Value)` where:
    + `LabelSym` is the symbol (or a new symbol generated by `gensym`)
    + `Index` is a variable representing the *eventual* location of the item
    + `Value` is either
        * HIR (for function defs) `hir(+HirInstrs:list)` or
        * The actual text content of a string constant. Maybe wrap this in a functor like `static_str("the content of my static string")`.
- Now you have a list of `lbl_idx_val/3` structures.

# Second Pass
- Pass over the HIR again:
    + expanding HIR instructions and immediates into bytes
    + keeping track of the index of each byte as it's expanded
    + removing `label(Lbl)` HIR instructions but unifying the corresponding `lbl_idx_val/3` structure with `lbl_idx_val(Lbl, CurrentByteIndex, nothing)`.
    + looking up the `Label`s in HIR `call(var(Label), _ArgC)` instructions, replacing them with `call_direct(Index, _ArgC)`

# Finally
- 